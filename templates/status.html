<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="{{ url_for('static', filename='favicon.svg') }}"
    />
    <title>ロボ研報告書作成ツール - 進行状況</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 2rem auto;
        max-width: 720px;
        color: #1f2933;
      }
      .credit {
        position: fixed;
        top: 0.75rem;
        right: 1rem;
        font-size: 0.75rem;
        color: #64748b;
        opacity: 0.85;
      }
      h1 {
        color: #0b7285;
      }
      .status-box {
        border: 1px solid #cbd5e1;
        border-radius: 8px;
        padding: 1.25rem;
        background: #f8fafc;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        flex-wrap: wrap;
      }
      .status-main {
        display: flex;
        flex-direction: column;
        gap: 0.05rem;
        flex: 1 1 auto;
        min-width: 240px;
      }
      .status-main > * {
        margin: 0;
      }
      .status-value {
        font-size: 1.2rem;
        font-weight: bold;
      }
      .status-message {
        font-style: italic;
      }
      .status-meta {
        font-size: 0.95rem;
        color: #475569;
      }
      .progress-wrapper {
        margin-top: 1.25rem;
      }
      .progress-track {
        width: 100%;
        height: 12px;
        background: #e2e8f0;
        border-radius: 999px;
        overflow: hidden;
      }
      .progress-bar {
        height: 100%;
        width: 0;
        background: linear-gradient(90deg, #0b7285, #38bdf8);
      }
      .progress-text {
        margin-top: 0.5rem;
        font-size: 0.95rem;
        color: #0f172a;
        font-weight: 600;
      }
      .completed {
        color: #2b8a3e;
      }
      .failed {
        color: #c92a2a;
      }
      .email-template {
        margin-top: 2rem;
        border: 1px solid #cbd5e1;
        border-radius: 10px;
        background: #f1f5f9;
        padding: 1.5rem;
      }
      .download-link {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: #0b7285;
        color: #fff;
        text-decoration: none;
        padding: 0.8rem 1.9rem;
        border-radius: 10px;
        font-weight: 600;
        font-size: 1rem;
        box-shadow: 0 6px 16px rgba(15, 23, 42, 0.18);
        white-space: nowrap;
        width: auto;
        flex-shrink: 0;
      }
      .download-link:hover {
        opacity: 0.92;
      }
      .email-template h2 {
        margin-top: 0;
        color: #0b7285;
      }
      .email-description {
        margin: 0 0 1rem 0;
        color: #334155;
        font-size: 0.95rem;
      }
      .template-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        margin-bottom: 1rem;
      }
      .template-controls label {
        display: flex;
        flex-direction: column;
        font-weight: 600;
        color: #1f2937;
        font-size: 0.95rem;
      }
      .template-controls select,
      .template-controls input {
        margin-top: 0.35rem;
        padding: 0.5rem 0.6rem;
        border-radius: 6px;
        border: 1px solid #cbd5e1;
        font-size: 1rem;
      }
      #email-template-text {
        width: 100%;
        min-height: 8rem;
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid #cbd5e1;
        font-size: 1rem;
        font-family: "Hiragino Sans", "Noto Sans JP", Arial, sans-serif;
        background: #fff;
        resize: vertical;
        box-sizing: border-box;
      }
      #copy-template {
        margin-top: 0.75rem;
        background: #0b7285;
        color: #fff;
        border: none;
        border-radius: 6px;
        padding: 0.6rem 1.25rem;
        font-size: 0.95rem;
        cursor: pointer;
      }
      #copy-template:hover {
        opacity: 0.92;
      }
      .copy-feedback {
        margin-top: 0.5rem;
        font-size: 0.9rem;
        color: #2b8a3e;
      }
      @media (max-width: 640px) {
        .template-controls {
          flex-direction: column;
        }
        .template-controls label {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="credit">制作者：石井遥紀 (2026年 修士卒業生)</div>
    <h1>処理状況</h1>
    <p>
      ジョブIDは <strong>{{ job_id }}</strong> です。<br>
      処理が完了するまで約0.1秒ごとに自動更新されます。
    </p>

    <div class="status-box">
      <div class="status-header">
        <div class="status-main">
          <div id="status" class="status-value">読み込み中…</div>
          <div id="message" class="status-message" hidden></div>
          <div id="timestamp" class="status-meta" hidden></div>
        </div>
        <a
          id="download-link"
          class="download-link"
          rel="noopener"
          download
          hidden
        ></a>
      </div>
    </div>

    <div id="progress-wrapper" class="progress-wrapper" hidden>
      <div
        id="progress-track"
        class="progress-track"
        role="progressbar"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="0"
      >
        <div id="progress-bar" class="progress-bar"></div>
      </div>
      <div id="progress-text" class="progress-text"></div>
    </div>

    <div id="email-template-section" class="email-template" hidden>
      <h2>先生にメールを送る場合の文章テンプレート</h2>
      <p class="email-description">班・学年・名前を設定すると文面が自動で更新されます。</p>
      <div class="template-controls">
        <label>
          班
          <select id="team-select">
            <option value="">（班を選択）</option>
          </select>
        </label>
        <label>
          学年
          <select id="grade-select">
            <option value="">（学年を選択）</option>
            <option value="B3">B3</option>
            <option value="B4">B4</option>
            <option value="M1">M1</option>
            <option value="M2">M2</option>
          </select>
        </label>
        <label>
          名前
          <input type="text" id="name-input" placeholder="氏名を入力" />
        </label>
      </div>
      <textarea id="email-template-text" rows="6" readonly></textarea>
      <button type="button" id="copy-template">テンプレートをコピー</button>
      <div id="copy-feedback" class="copy-feedback" role="status" aria-live="polite"></div>
    </div>

    <script>
      const statusUrl = "{{ url_for('job_status', job_id=job_id) }}";
      const statusLabels = {
        queued: "待機中",
        running: "処理中",
        completed: "完了",
        failed: "失敗",
      };
      const emailSection = document.getElementById("email-template-section");
      const teamSelect = document.getElementById("team-select");
      const gradeSelect = document.getElementById("grade-select");
      const nameInput = document.getElementById("name-input");
      const emailTextArea = document.getElementById("email-template-text");
      const copyButton = document.getElementById("copy-template");
      const copyFeedback = document.getElementById("copy-feedback");
      const progressWrapper = document.getElementById("progress-wrapper");
      const progressTrack = document.getElementById("progress-track");
      const progressBar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      const downloadLink = document.getElementById("download-link");
      if (downloadLink) {
        downloadLink.hidden = true;
        downloadLink.style.display = "none";
      }
      let teamOptionsInitialized = false;
      let currentReportNumber = "";
      const downloadUrl = "{{ url_for('download_merged_pdf', job_id=job_id) }}";
      const animationIntervalMs = 10;
      const nowFn = () =>
        typeof performance !== "undefined" && typeof performance.now === "function"
          ? performance.now()
          : Date.now();
      let animationTimerId = null;
      let targetPercentValue = 0;
      let displayedPercentValue = 0;
      let displayedPixelValue = 0;
      let pixelAccumulator = 0;
      let percentPerSecondValue = 0;
      let lastPercentSample = 0;
      let lastPercentSampleTime = nowFn();

      function syncProgressBarWidth() {
        if (!progressTrack || !progressBar) {
          return;
        }
        const trackWidth = progressTrack.clientWidth;
        if (trackWidth <= 0) {
          return;
        }
        const targetPixels = Math.round((targetPercentValue / 100) * trackWidth);
        displayedPixelValue = Math.min(
          targetPixels,
          Math.round((displayedPercentValue / 100) * trackWidth)
        );
        displayedPercentValue = trackWidth
          ? (displayedPixelValue / trackWidth) * 100
          : displayedPercentValue;
        progressBar.style.width = `${displayedPixelValue}px`;
      }

      function stepProgressAnimation() {
        if (!progressTrack || !progressBar) {
          return;
        }
        const trackWidth = progressTrack.clientWidth;
        if (trackWidth <= 0) {
          return;
        }
        const targetPixels = Math.round((targetPercentValue / 100) * trackWidth);
        if (displayedPixelValue >= targetPixels) {
          displayedPixelValue = targetPixels;
          displayedPercentValue = trackWidth
            ? (displayedPixelValue / trackWidth) * 100
            : targetPercentValue;
          progressBar.style.width = `${displayedPixelValue}px`;
          if (
            targetPercentValue >= 100 &&
            animationTimerId !== null &&
            displayedPixelValue === targetPixels
          ) {
            clearInterval(animationTimerId);
            animationTimerId = null;
          }
          return;
        }

        let effectivePercentPerSecond = percentPerSecondValue;
        if (!Number.isFinite(effectivePercentPerSecond) || effectivePercentPerSecond <= 0) {
          const remainingPercent = targetPercentValue - displayedPercentValue;
          effectivePercentPerSecond = remainingPercent > 0 ? Math.max(remainingPercent * 0.5, 5) : 0;
        }
        if (effectivePercentPerSecond <= 0) {
          return;
        }

        const percentIncrement =
          effectivePercentPerSecond * (animationIntervalMs / 1000);
        if (percentIncrement <= 0) {
          return;
        }

        const incrementPixels = (percentIncrement / 100) * trackWidth;
        if (incrementPixels <= 0) {
          return;
        }

        pixelAccumulator += incrementPixels;
        if (pixelAccumulator < 1) {
          return;
        }

        let pixelsToAdvance = Math.floor(pixelAccumulator);
        const remainingPixels = targetPixels - displayedPixelValue;
        if (pixelsToAdvance > remainingPixels) {
          pixelsToAdvance = remainingPixels;
          pixelAccumulator = 0;
        } else {
          pixelAccumulator -= pixelsToAdvance;
        }

        if (pixelsToAdvance <= 0) {
          return;
        }

        displayedPixelValue += pixelsToAdvance;
        displayedPercentValue = trackWidth
          ? (displayedPixelValue / trackWidth) * 100
          : displayedPercentValue;
        progressBar.style.width = `${displayedPixelValue}px`;
      }

      function ensureProgressAnimation() {
        if (animationTimerId === null) {
          animationTimerId = setInterval(stepProgressAnimation, animationIntervalMs);
        }
      }

      function resetProgressAnimation() {
        if (animationTimerId !== null) {
          clearInterval(animationTimerId);
          animationTimerId = null;
        }
        targetPercentValue = 0;
        displayedPercentValue = 0;
        displayedPixelValue = 0;
        pixelAccumulator = 0;
        percentPerSecondValue = 0;
        lastPercentSample = 0;
        lastPercentSampleTime = nowFn();
        if (progressBar) {
          progressBar.style.width = "0px";
        }
      }

      function updateProgressTarget(nextPercent) {
        if (typeof nextPercent !== "number" || Number.isNaN(nextPercent)) {
          return;
        }
        const clamped = Math.min(100, Math.max(0, nextPercent));
        const currentTime = nowFn();
        if (clamped !== lastPercentSample) {
          const percentDelta = clamped - lastPercentSample;
          const elapsedMs = currentTime - lastPercentSampleTime;
          if (percentDelta > 0 && elapsedMs > 0) {
            const computedPercentPerSecond = (percentDelta / elapsedMs) * 1000;
            if (
              Number.isFinite(computedPercentPerSecond) &&
              computedPercentPerSecond > 0
            ) {
              percentPerSecondValue = computedPercentPerSecond;
            }
          } else if (percentDelta < 0) {
            percentPerSecondValue = 0;
          }
          lastPercentSample = clamped;
          lastPercentSampleTime = currentTime;
        }

        targetPercentValue = clamped;
        if (displayedPercentValue > targetPercentValue) {
          displayedPercentValue = targetPercentValue;
          pixelAccumulator = 0;
          syncProgressBarWidth();
        }
        ensureProgressAnimation();
      }

      window.addEventListener("resize", () => {
        pixelAccumulator = 0;
        syncProgressBarWidth();
      });

      function populateTeamOptions(options) {
        if (!teamSelect || teamOptionsInitialized) {
          return;
        }
        const uniqueOptions = Array.from(
          new Set(
            Array.isArray(options)
              ? options
                  .map((option) => (typeof option === "string" ? option.trim() : ""))
                  .filter((option) => option)
              : []
          )
        );
        teamSelect.innerHTML = "";
        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = "（班を選択）";
        teamSelect.appendChild(placeholder);
        uniqueOptions.forEach((option) => {
          const element = document.createElement("option");
          element.value = option;
          element.textContent = option;
          teamSelect.appendChild(element);
        });
        teamSelect.value = "";
        teamOptionsInitialized = true;
      }

      function formatTeamLabel(value) {
        const trimmed = value.trim();
        if (!trimmed) {
          return "◯◯班";
        }
        if (trimmed === "班なし") {
          return trimmed;
        }
        return trimmed.endsWith("班") ? trimmed : `${trimmed}班`;
      }

      function updateEmailText() {
        if (!emailTextArea) {
          return;
        }
        if (!currentReportNumber) {
          emailTextArea.value = "";
          return;
        }
        const teamValue = teamSelect ? teamSelect.value || "" : "";
        const gradeValue = gradeSelect ? gradeSelect.value || "" : "";
        const nameValue = nameInput ? nameInput.value.trim() : "";
        const placeholderTeam = "◯◯班";
        const placeholderGrade = "(学年)";
        const placeholderName = "(名前)";
        const teamLabel = teamValue ? formatTeamLabel(teamValue) : placeholderTeam;
        const gradeLabel = gradeValue || placeholderGrade;
        const nameLabel = nameValue || placeholderName;
        const teamGradeSeparator = gradeValue ? (teamValue ? "" : " ") : " ";
        const gradeNameSeparator = nameValue ? "の" : " の ";
        emailTextArea.value = `お世話になっております。${teamLabel}${teamGradeSeparator}${gradeLabel}${gradeNameSeparator}${nameLabel}です。\n第${currentReportNumber}回報告書を添付しております。\nよろしくお願いいたします。`;
      }

      if (teamSelect) {
        teamSelect.addEventListener("change", updateEmailText);
      }
      if (gradeSelect) {
        gradeSelect.addEventListener("change", updateEmailText);
      }
      if (nameInput) {
        nameInput.addEventListener("input", updateEmailText);
      }
      if (copyButton) {
        copyButton.addEventListener("click", async () => {
          if (!emailTextArea || !emailTextArea.value) {
            return;
          }
          try {
            await navigator.clipboard.writeText(emailTextArea.value);
            if (copyFeedback) {
              copyFeedback.style.color = "#2b8a3e";
              copyFeedback.textContent = "テンプレートをコピーしました。";
            }
          } catch (error) {
            if (copyFeedback) {
              copyFeedback.textContent = "クリップボードへのコピーに失敗しました。";
              copyFeedback.style.color = "#c92a2a";
            }
          }
        });
      }

      async function refreshStatus() {
        try {
          const response = await fetch(statusUrl);
          if (!response.ok) {
            throw new Error("ステータスを取得できませんでした");
          }
          const data = await response.json();
          let shouldStopPolling = false;
          const statusElement = document.getElementById("status");
          const messageElement = document.getElementById("message");
          const timestampElement = document.getElementById("timestamp");

          statusElement.textContent = statusLabels[data.status] || data.status;
          statusElement.className = "status-value " + data.status;
          const messageText =
            typeof data.message === "string" ? data.message.trim() : "";
          if (messageElement) {
            if (messageText) {
              messageElement.textContent = messageText;
              messageElement.hidden = false;
            } else {
              messageElement.textContent = "";
              messageElement.hidden = true;
            }
          }

          let updatedAtText = "";
          if (data.updated_at) {
            updatedAtText =
              "更新日時: " +
              new Date(data.updated_at).toLocaleString("ja-JP", {
                timeZone: "Asia/Tokyo",
              });
          }
          let metaText = updatedAtText;

          const totalStepsValue = Number(data.progress_total);
          const currentStepsValue = Number(data.progress_current);
          const hasTotal = Number.isFinite(totalStepsValue) && totalStepsValue > 0;
          const currentSteps = Number.isFinite(currentStepsValue)
            ? Math.max(0, currentStepsValue)
            : 0;
          const totalSteps = hasTotal ? totalStepsValue : 0;
          let percentValue =
            typeof data.progress_percent === "number" ? data.progress_percent : null;
          if (percentValue === null && totalSteps > 0) {
            percentValue = Math.round((currentSteps / totalSteps) * 100);
          }
          if (percentValue === null) {
            percentValue = 0;
          }
          const safePercent = Math.min(100, Math.max(0, percentValue));

          if (progressWrapper) {
            if (totalSteps > 0) {
              progressWrapper.hidden = false;
              updateProgressTarget(safePercent);
              if (progressTrack) {
                progressTrack.setAttribute(
                  "aria-valuenow",
                  String(Math.round(safePercent))
                );
              }
              if (progressText) {
                progressText.textContent = `進捗: ${safePercent}%`;
              }
            } else {
              progressWrapper.hidden = true;
              if (progressText) {
                progressText.textContent = "";
              }
              resetProgressAnimation();
            }
          }

          if (!teamOptionsInitialized && data.team_options) {
            populateTeamOptions(data.team_options);
          }

          if (data.status === "completed") {
            const reportNumberRaw =
              typeof data.report_number === "string" ? data.report_number.trim() : "";
            const shouldShowCompletionDetails = reportNumberRaw.length > 0;
            currentReportNumber = shouldShowCompletionDetails ? reportNumberRaw : "";
            if (downloadLink) {
              if (shouldShowCompletionDetails) {
                const fileName =
                  typeof data.final_pdf_name === "string" ? data.final_pdf_name.trim() : "";
                downloadLink.textContent = `第${currentReportNumber}回報告書をダウンロード`;
                downloadLink.href = `${downloadUrl}?t=${Date.now()}`;
                if (fileName) {
                  downloadLink.setAttribute("download", fileName);
                } else {
                  downloadLink.removeAttribute("download");
                }
                downloadLink.hidden = false;
                downloadLink.style.display = "inline-flex";
              } else {
                downloadLink.hidden = true;
                downloadLink.style.display = "none";
                downloadLink.textContent = "";
                downloadLink.removeAttribute("href");
                downloadLink.removeAttribute("download");
              }
            }
            if (emailSection) {
              emailSection.hidden = !shouldShowCompletionDetails;
            }
            if (shouldShowCompletionDetails) {
              updateEmailText();
              shouldStopPolling = true;
            } else if (emailTextArea) {
              emailTextArea.value = "";
            }
            if (data.elapsed_display) {
              metaText = `総経過時間: ${data.elapsed_display}`;
            }
          } else {
            if (downloadLink) {
              downloadLink.hidden = true;
              downloadLink.style.display = "none";
              downloadLink.textContent = "";
              downloadLink.removeAttribute("href");
              downloadLink.removeAttribute("download");
            }
            if (emailSection) {
              emailSection.hidden = true;
            }
            if (emailTextArea) {
              emailTextArea.value = "";
            }
            currentReportNumber = "";
          }

          if (timestampElement) {
            if (metaText) {
              timestampElement.textContent = metaText;
              timestampElement.hidden = false;
            } else {
              timestampElement.textContent = "";
              timestampElement.hidden = true;
            }
          }

          if (shouldStopPolling || data.status === "failed") {
            return;
          }
        } catch (error) {
          const statusElement = document.getElementById("status");
          const messageElement = document.getElementById("message");
          if (statusElement) {
            statusElement.textContent = "エラー";
          }
          if (messageElement) {
            messageElement.textContent = String(error);
            messageElement.hidden = false;
          }
        }
        setTimeout(refreshStatus, 100);
      }

      refreshStatus();
    </script>
  </body>
</html>